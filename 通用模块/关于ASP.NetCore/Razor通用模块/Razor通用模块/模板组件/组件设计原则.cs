
/*在设计组件时，请遵循以下原则：
  
  #除没有UI的组件（例如Router）以外，所有组件都应该派生自TemplatedComponents，
  以提供模板化功能，这种设计的灵感来自WPF的控件模板，
  能够将组件的外观和组件的功能分离开来，
  模板是一个类型为RenderFragment<TemplatedComponents>的委托，它负责呈现组件，
  组件负责提供呈现所必须的数据，以及处理事件连接，
  在呈现组件时，组件会将自身作为参数传入模板，模板可以通过这个参数与组件通讯

  #在声明模板时，不要硬编码子元素的属性，
  而是仅设置class属性，该属性能够为子元素提供默认样式

  #class的值应该被作为一个常量储存在专门的静态类型中，
  该类型的命名格式为CSS{描述}Vocabulary，
  这是为了在不同程序集之间共享class的值

  #默认样式的实现应该放在本程序集的wwwroot/css/DefaultStyle.css文件中，
  引用本程序集的项目也可以编写自己的实现，并通过css的伪继承机制扩展默认样式，伪继承的解释如下：

  如果网页引用了两个css文件，而且它们包含同名的class选择器，那么按照以下原则渲染网页：
  1.如果两个选择器中设置的属性没有冲突，则取它们的并集
  2.如果存在属性冲突，那么在head标签中先引用的css文件具有更高的优先级
  3.作者没有详细阅读CSS标准，但是经测试，Chrome和Firefox两大浏览器内核都遵循这个原则，
  因此可以认为这个行为是符合标准的，应该不会出现兼容性问题

  通过伪继承扩展默认样式的方法如下：
  1.假设要扩展的class叫demonstrate，则在新项目中引用本程序集，
  然后新建一个css文件，假设该文件的名称叫extended.css
  2.在extended.css中声明一个class选择器，名称也叫demonstrate，
  并在该选择器中声明想要扩展或修改的属性
  3.在head标签中先引用新程序集的extended.css，
  然后再引用本程序集中的DefaultStyle.css，顺序不能颠倒，
  如此一来，两个css文件的demonstrate选择器中没有冲突的属性会被合并，
  有冲突的属性会以extended.css中声明的为准，默认样式扩展完成

  #如果通过扩展样式仍然无法满足需求，可直接重写组件模板

  注意事项：

  #在满足以下条件时，Razor页面将无法编译通过：
  1.在Razor页面中显式声明RenderFragment委托
  2.该委托需要用到Razor语法，且以语句而不是表达式的形式声明
  3.委托参数名称不为__builder，将它改为这个名称可以解决该问题
  这个问题是由于Razor编译器的缺陷所导致，因为在这种情况下，
  编译器不能识别RenderFragment委托参数的新名称，而是会将它们一律编译为__builder，
  这会导致找不到未经声明的参数而引发错误，该问题可以稳定复现，
  如果对其感兴趣，可以查看编译生成的C#类型*/
